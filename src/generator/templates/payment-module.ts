/**
 * Payment Module Template
 *
 * Generates a React Native component that demonstrates how to collect
 * a payment using a connected Solana wallet and a merchant account.
 */

import type { TemplateContext } from '../types.js';

export function generatePaymentModule(context: TemplateContext): string {
  const { projectName, useTypeScript, solanaCluster } = context;
  const clusterEndpoint =
    solanaCluster === 'mainnet-beta'
      ? 'https://api.mainnet-beta.solana.com'
      : solanaCluster === 'testnet'
        ? 'https://api.testnet.solana.com'
        : 'https://api.devnet.solana.com';

  const typeDefinitions = useTypeScript
    ? `
interface PaymentModuleProps {
  merchantAddress: string;
  memo?: string;
  defaultAmountSol?: number;
  paymentServerUrl?: string;
  onSuccess?: (signature: string) => void;
  onError?: (error: Error) => void;
}`
    : '';

  const propAnnotation = useTypeScript ? ': PaymentModuleProps' : '';

  return `/**
 * WalletPaymentModule
 *
 * Demonstrates how to route a transfer through a Solana wallet connected via
 * the Mobile Wallet Adapter protocol and optionally notify your backend.
 * Generated by SeekerMigrate for ${projectName}
 * @generated
 */

import React, { useCallback, useMemo, useState } from 'react';
import {
  ActivityIndicator,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from 'react-native';
import { Connection, LAMPORTS_PER_SOL, PublicKey, SystemProgram, Transaction } from '@solana/web3.js';
import { useWallet } from '@solana/wallet-adapter-react';

${typeDefinitions}

const connection = new Connection('${clusterEndpoint}', { commitment: 'confirmed' });

export function WalletPaymentModule({
  merchantAddress,
  memo,
  defaultAmountSol = 0.01,
  paymentServerUrl = '/api/payments',
  onSuccess,
  onError,
}${propAnnotation}) {
  const { publicKey, connected, sendTransaction } = useWallet();
  const [amountSol, setAmountSol] = useState(defaultAmountSol.toString());
  const [status, setStatus] = useState<'idle' | 'processing' | 'success' | 'error'>('idle');
  const [message, setMessage] = useState<string | null>(null);

  const parsedAmount = useMemo(() => {
    const parsed = Number(amountSol) || defaultAmountSol;
    return Math.max(parsed, 0.0001);
  }, [amountSol, defaultAmountSol]);

  const displayAmount = useMemo(() => {
    const formatted =
      parsedAmount === defaultAmountSol
        ? parsedAmount.toFixed(4)
        : parsedAmount.toFixed(6);
    return formatted + ' SOL';
  }, [parsedAmount, defaultAmountSol]);

  const handlePayment = useCallback(async () => {
    if (!connected || !publicKey || !sendTransaction) {
      setMessage('Connect your wallet before sending payments.');
      setStatus('error');
      return;
    }

    const lamports = Math.round(parsedAmount * LAMPORTS_PER_SOL);

    try {
      setStatus('processing');
      setMessage(null);

      const transaction = new Transaction({
        feePayer: publicKey,
      }).add(
        SystemProgram.transfer({
          fromPubkey: publicKey,
          toPubkey: new PublicKey(merchantAddress),
          lamports,
        })
      );

      const latestBlockhash = await connection.getLatestBlockhash();
      transaction.recentBlockhash = latestBlockhash.blockhash;

      const signature = await sendTransaction(transaction, connection);
      await connection.confirmTransaction(signature, 'confirmed');

      await fetch(paymentServerUrl + '/receipt', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          merchant: merchantAddress,
          amountLamports: lamports,
          memo,
          signature,
        }),
      });

      setStatus('success');
      setMessage(
        'Payment sent (signature: ' + signature.slice(0, 8) + '...)'
      );
      onSuccess?.(signature);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Payment failed (unknown error)';
      setStatus('error');
      setMessage(errorMessage);
      onError?.(error instanceof Error ? error : new Error(errorMessage));
    }
  }, [connected, merchantAddress, memo, onError, onSuccess, parsedAmount, paymentServerUrl, publicKey, sendTransaction]);

  const statusColor = useMemo(() => {
    switch (status) {
      case 'success':
        return '#14F195';
      case 'error':
        return '#FF6B6B';
      case 'processing':
        return '#FFA500';
      default:
        return '#FFFFFF';
    }
  }, [status]);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Send a payment</Text>
      <Text style={styles.subtitle}>
        This route sends {displayAmount} to {merchantAddress}
      </Text>

      <TextInput
        style={styles.input}
        keyboardType="decimal-pad"
        value={amountSol.toString()}
        onChangeText={setAmountSol}
        placeholder="Amount (SOL)"
        placeholderTextColor="#888"
      />

      <TouchableOpacity
        style={[styles.button, { backgroundColor: status === 'processing' ? '#666' : '#9945FF' }]}
        onPress={handlePayment}
        disabled={status === 'processing'}
        activeOpacity={0.8}
      >
        {status === 'processing' ? (
          <ActivityIndicator color="#FFFFFF" />
        ) : (
          <Text style={styles.buttonText}>Pay with Wallet</Text>
        )}
      </TouchableOpacity>

      {message ? (
        <Text style={[styles.message, { color: statusColor }]}>{message}</Text>
      ) : (
        <Text style={styles.explain}>
          The wallet will sign a transfer. Your backend can reconcile the payment
          using the optional /receipt endpoint above.
        </Text>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    padding: 20,
    borderRadius: 16,
    backgroundColor: '#1A1A1A',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.25,
    shadowRadius: 10,
    elevation: 6,
    gap: 12,
  },
  title: {
    color: '#FFFFFF',
    fontSize: 18,
    fontWeight: '700',
  },
  subtitle: {
    color: '#AAAAAA',
    fontSize: 13,
  },
  input: {
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.2)',
    padding: 12,
    borderRadius: 10,
    color: '#FFFFFF',
    fontSize: 16,
  },
  button: {
    paddingVertical: 14,
    borderRadius: 12,
    alignItems: 'center',
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  message: {
    fontSize: 14,
    fontWeight: '500',
  },
  explain: {
    fontSize: 13,
    color: '#888',
  },
});

export default WalletPaymentModule;
`;
}
