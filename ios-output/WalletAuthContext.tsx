/**
 * WalletAuthContext
 *
 * Provides wallet-based authentication state throughout the app.
 * This replaces Firebase Auth context with Solana wallet authentication.
 *
 * Generated by SeekerMigrate for sample-ios-firebase-app
 * @generated
 */

import React, {
  createContext,
  useContext,
  useState,
  useCallback,
  useMemo,
  useEffect,
} from 'react';
import { useWallet, useConnection } from '@solana/wallet-adapter-react';
import { PublicKey, Transaction } from '@solana/web3.js';
import {
  transact,
  Web3MobileWallet,
} from '@solana-mobile/mobile-wallet-adapter-protocol-web3js';

/**
 * User object representing the authenticated wallet user
 */
interface WalletUser {
  /** Wallet public key as base58 string */
  publicKey: string;
  /** Full PublicKey object */
  publicKeyObj: PublicKey;
}

/**
 * Auth context value type
 */
interface AuthContextValue {
  /** Current authenticated user (null if not connected) */
  user: WalletUser | null;
  /** Whether a wallet is currently connected */
  isAuthenticated: boolean;
  /** Whether wallet connection is in progress */
  isLoading: boolean;
  /** Sign a message with the connected wallet */
  signMessage: (message: string) => Promise<Uint8Array | null>;
  /** Sign and send a transaction */
  signTransaction: (transaction: Transaction) => Promise<Transaction | null>;
  /** Request wallet authorization */
  authorize: () => Promise<boolean>;
  /** Deauthorize the wallet */
  deauthorize: () => Promise<void>;
  /** Error from last operation */
  error: Error | null;
}


const AuthContext = createContext<AuthContextValue | null>(null);

/**
 * Hook to access the wallet auth context
 */
export function useAuth(): AuthContextValue {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within a WalletAuthProvider');
  }
  return context;
}

/**
 * Provider component for wallet-based authentication
 */
export function WalletAuthProvider({ children }: { children: React.ReactNode }) {
  const { publicKey, connected, connecting, signMessage: walletSignMessage } = useWallet();
  const { connection } = useConnection();
  const [error, setError] = useState<Error | null>(null);
  const [authToken, setAuthToken] = useState<string | null>(null);

  // Create user object from wallet state
  const user = useMemo(() => {
    if (!publicKey || !connected) return null;
    return {
      publicKey: publicKey.toBase58(),
      publicKeyObj: publicKey,
    };
  }, [publicKey, connected]);

  // Authorize with Mobile Wallet Adapter
  const authorize = useCallback(async (): Promise<boolean> => {
    setError(null);
    try {
      const result = await transact(async (wallet: Web3MobileWallet) => {
        const authorization = await wallet.authorize({
          chain: 'solana:devnet', // Change for production
          identity: {
            name: 'sample-ios-firebase-app',
            uri: 'https://your-app-url.com',
            icon: 'favicon.ico',
          },
        });
        return authorization;
      });

      if (result?.authToken) {
        setAuthToken(result.authToken);
        return true;
      }
      return false;
    } catch (err) {
      setError(err as Error);
      return false;
    }
  }, []);

  // Deauthorize wallet
  const deauthorize = useCallback(async () => {
    setError(null);
    try {
      if (authToken) {
        await transact(async (wallet: Web3MobileWallet) => {
          await wallet.deauthorize({ authToken });
        });
      }
      setAuthToken(null);
    } catch (err) {
      setError(err as Error);
    }
  }, [authToken]);

  // Sign a message using the wallet
  const signMessage = useCallback(
    async (message: string): Promise<Uint8Array | null> => {
      setError(null);
      if (!connected || !walletSignMessage) {
        setError(new Error('Wallet not connected'));
        return null;
      }

      try {
        const messageBytes = new TextEncoder().encode(message);
        const signature = await walletSignMessage(messageBytes);
        return signature;
      } catch (err) {
        setError(err as Error);
        return null;
      }
    },
    [connected, walletSignMessage]
  );

  // Sign a transaction using Mobile Wallet Adapter
  const signTransaction = useCallback(
    async (transaction: Transaction): Promise<Transaction | null> => {
      setError(null);
      if (!connected || !publicKey) {
        setError(new Error('Wallet not connected'));
        return null;
      }

      try {
        const signedTx = await transact(async (wallet: Web3MobileWallet) => {
          // Reauthorize if needed
          const authorization = await wallet.authorize({
            chain: 'solana:devnet',
            identity: {
              name: 'sample-ios-firebase-app',
              uri: 'https://your-app-url.com',
              icon: 'favicon.ico',
            },
          });

          // Get latest blockhash
          const { blockhash, lastValidBlockHeight } =
            await connection.getLatestBlockhash();
          transaction.recentBlockhash = blockhash;
          transaction.feePayer = new PublicKey(authorization.publicKey);

          // Sign the transaction
          const signedTransactions = await wallet.signTransactions({
            transactions: [transaction],
          });

          return signedTransactions[0];
        });

        return signedTx;
      } catch (err) {
        setError(err as Error);
        return null;
      }
    },
    [connected, publicKey, connection]
  );

  // Context value
  const value = useMemo(
    (): AuthContextValue => ({
      user,
      isAuthenticated: connected && !!publicKey,
      isLoading: connecting,
      signMessage,
      signTransaction,
      authorize,
      deauthorize,
      error,
    }),
    [
      user,
      connected,
      publicKey,
      connecting,
      signMessage,
      signTransaction,
      authorize,
      deauthorize,
      error,
    ]
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export default WalletAuthProvider;
